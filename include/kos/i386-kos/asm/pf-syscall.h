/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef _KOS_I386_KOS_ASM_PF_SYSCALL_H
#define _KOS_I386_KOS_ASM_PF_SYSCALL_H 1

#include <__stdinc.h>
#include <hybrid/host.h>
#include <features.h>

__SYSDECL_BEGIN

/* Encode a system call vector address for use with `ts_syscall'.
 * This type of system call invocation was originally designed to implement `sigreturn'
 * without the need of mapping a piece of kernel code into user-space by
 * simply having a signal handler function ~return~ into kernel-space.
 * >>signal_handler:
 * >>    ...
 * >>    ret
 * >> 
 * >>foobar:
 * >>    ... // Generate an on-stack signal-frame, as described
 * >>        // by `/src/kernel/i386-kos/posix_signal.c'
 * >>    
 * >>    movl   %taskseg:TASK_SEGMENT_OFFSETOF_X86SYSBASE, %eax
 * >>    leal   X86_ENCODE_PFSYSCALL(SYS_sigreturn)(%eax), %eax
 * >>    pushl  %eax // ~supposed~ return address
 * >>    jmp    signal_handler
 * Once `signal_handler' returns, it will try to jump to a kernel-space address,
 * which then causes a PAGEFAULT as user-space isn't allowed to access that memory.
 * NOTE: This only works when the kernel detects
 *      `EIP == CR2 && CR2 in [ts_sysbase ... += X86_ENCODE_PFSYSCALL_SIZE]',
 *       meaning that regular pagefaults for that address range do not trigger
 *       this behavior. - Only jumping into that range does.
 * Special rules for these types of system calls:
 *  - The system call number is encoded as part of the
 *    faulting address (s.a. `X86_DECODE_PFSYSCALL')
 *  - Since this method involves `EIP == CR2', but leaves EAX unused, PF-syscall
 *    convention follows that of the `int $0x80' instruction with the addition
 *    of using EAX as return address register.
 *    Note however that system calls which never actually return do not make
 *    use of the return address, meaning that those are the only ones that
 *    can safely (and easily) be used for redirected function return addresses.
 *  - The kernel is aware of the special case of the return address override
 *    generated by a signal frame, which would normally redirect a user-space
 *    stack frame into kernel-space, or more precisely, at
 *    `ts_x86sysbase + X86_ENCODE_PFSYSCALL(SYS_sigreturn)'
 *    Knowing that, as well as the ~real~ (kernel-side) value of `ts_x86sysbase',
 *    KOS will correctly unwind signal frames when using the `SYS_xunwind'
 *    system call, or when throwing an exception from within a signal handler. */
#define __X86_ENCODE_PFSYSCALL(sysno) \
      (((sysno) & 0xffff) | ((sysno) & 0xc0000000) >> 14)
#define __X86_DECODE_PFSYSCALL(rel_faultaddr) \
      (((rel_faultaddr) & 0xffff) | ((rel_faultaddr) & 0x30000) << 14)
#define __X86_ENCODE_PFSYSCALL_BITS 18 /* 16 ID bits; +1 for xsyscalls; +1 for exception mode. */
#define __X86_ENCODE_PFSYSCALL_SIZE (1 << __X86_ENCODE_PFSYSCALL_BITS)
#define __X86_ENCODE_PFSYSCALL_XBIT 0x20000 /* Exception bit. */

#if defined(__USE_KOS) || defined(__KERNEL__)
#define X86_ENCODE_PFSYSCALL(sysno)         __X86_ENCODE_PFSYSCALL(sysno)
#define X86_DECODE_PFSYSCALL(rel_faultaddr) __X86_DECODE_PFSYSCALL(rel_faultaddr)
#define X86_ENCODE_PFSYSCALL_BITS           __X86_ENCODE_PFSYSCALL_BITS
#define X86_ENCODE_PFSYSCALL_SIZE           __X86_ENCODE_PFSYSCALL_SIZE
#define X86_ENCODE_PFSYSCALL_XBIT           __X86_ENCODE_PFSYSCALL_XBIT
#endif

__SYSDECL_END

#endif /* !_KOS_I386_KOS_ASM_PF_SYSCALL_H */
